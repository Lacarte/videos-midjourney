{"extVersion":"1.29.12","name":"midvideo-downloader ðŸŽ¥ðŸŽ¨","icon":"riGlobalLine","table":[],"version":"1.29.12","drawflow":{"edges":[{"class":"connected-edges","data":{},"id":"vueflow__edge-vj0n92nvj0n92n-output-1-j3zta88j3zta88-input-1","label":"","markerEnd":"arrowclosed","selectable":true,"source":"tldasqk","sourceHandle":"tldasqk-output-1","sourceX":780.9060359218086,"sourceY":294.58142652386994,"target":"j3zta88","targetHandle":"j3zta88-input-1","targetX":873.3989027508103,"targetY":295.9648699314941,"type":"custom","updatable":true},{"class":"connected-edges","data":{},"id":"vueflow__edge-j3zta88j3zta88-output-1-c3kvt56c3kvt56-input-1","label":"","markerEnd":"arrowclosed","selectable":true,"source":"j3zta88","sourceHandle":"j3zta88-output-1","sourceX":1113.3990678505502,"sourceY":295.9648699314941,"target":"c3kvt56","targetHandle":"c3kvt56-input-1","targetX":1185.9931219132538,"targetY":446.7345028296853,"type":"custom","updatable":true},{"data":{},"id":"vueflow__edge-c3kvt56c3kvt56-output-1-0gr5xyo0gr5xyo-input-1","label":"","markerEnd":"arrowclosed","selectable":true,"source":"c3kvt56","sourceHandle":"c3kvt56-output-1","sourceX":1425.9932870129937,"sourceY":446.7345028296853,"target":"0gr5xyo","targetHandle":"0gr5xyo-input-1","targetX":1519.9280729385555,"targetY":316.1135739333499,"type":"custom","updatable":true},{"data":{},"id":"vueflow__edge-c3kvt56c3kvt56-output-fallback-jl836mqjl836mq-input-1","label":"","markerEnd":"arrowclosed","selectable":true,"source":"c3kvt56","sourceHandle":"c3kvt56-output-fallback","sourceX":1425.9932870129937,"sourceY":468.7345708041368,"target":"jl836mq","targetHandle":"jl836mq-input-1","targetX":1518.2744431977324,"targetY":637.2086486744112,"type":"custom","updatable":true},{"data":{},"id":"vueflow__edge-ra25aifra25aif-output-1-vj0n92nvj0n92n-input-1","label":"","markerEnd":"arrowclosed","selectable":true,"source":"ra25aif","sourceHandle":"ra25aif-output-1","sourceX":406.2506419213688,"sourceY":294.6687040011073,"target":"tldasqk","targetHandle":"tldasqk-input-1","targetX":540.9058708220687,"targetY":294.58142652386994,"type":"custom","updatable":true}],"nodes":[{"data":{"code":"(() => {\n  class VideoURLCollector {\n    constructor(options = {}) {\n      // --- Required scroll container: #pageScroll\n      const container = options.scrollContainer || document.getElementById('pageScroll');\n      if (!container) {\n        throw new Error('Scroll container #pageScroll not found. Ensure the page has <div id=\"pageScroll\">.');\n      }\n      this.scrollContainer = container;\n\n      // --- Config\n      this.maxVideos       = options.maxVideos ?? 25;\n      this.waitTime        = options.waitTime ?? 900;      // ms after each scroll\n      this.loadTimeout     = options.loadTimeout ?? 4000;  // max wait for new nodes per round\n      this.maxStaleRounds  = options.maxStaleRounds ?? 6;  // stop if N rounds produce 0 new URLs\n\n      // Sensible default step: ~80% of viewport height (min 200)\n      const defaultStep    = Math.max(200, Math.floor(this.scrollContainer.clientHeight * 0.8));\n      this.scrollStep      = options.scrollStep ?? defaultStep;\n\n      // Optional site-specific selectors to scan for URLs (src/href)\n      this.extraSelectors  = options.extraSelectors ?? [];\n\n      this.videoUrls = new Set();\n      this.isRunning = false;\n    }\n\n    /* -------------------- Utilities -------------------- */\n    delay(ms) { return new Promise(res => setTimeout(res, ms)); }\n\n    // CSS.escape fallback (older engines)\n    static cssEscape(str) {\n      if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(str);\n      return String(str).replace(/[^a-zA-Z0-9_\\-]/g, s => '\\\\' + s.charCodeAt(0).toString(16) + ' ');\n    }\n\n    normalizeUrl(url) {\n      if (!url) return null;\n      try {\n        const u = new URL(url, location.href);\n        u.hash = \"\"; // strip hash to reduce dupes\n        return u.href;\n      } catch {\n        return null;\n      }\n    }\n\n    getScrollMetrics() {\n      const c = this.scrollContainer;\n      return {\n        top: c.scrollTop,\n        height: c.clientHeight,\n        scrollHeight: c.scrollHeight\n      };\n    }\n\n    canScrollDown() {\n      const { top, height, scrollHeight } = this.getScrollMetrics();\n      return top + height < (scrollHeight - 1);\n    }\n    canScrollUp() {\n      const { top } = this.getScrollMetrics();\n      return top > 0;\n    }\n\n    /* -------------------- Scrolling -------------------- */\n    async scrollAndWait() {\n      const c = this.scrollContainer;\n      const { top, height, scrollHeight } = this.getScrollMetrics();\n\n      // Nudge up a bit (helps some lazy-loaders re-fire intersections)\n      if (this.canScrollUp()) {\n        c.scrollTop = Math.max(0, top - Math.floor(this.scrollStep / 3));\n        await this.delay(80);\n      }\n\n      // Scroll down by step without overshooting bottom\n      const before = c.scrollTop;\n      const target = Math.min(before + this.scrollStep, scrollHeight - height);\n      c.scrollTop = target;\n\n      // Write again on next frame to defeat throttling\n      await new Promise(r => requestAnimationFrame(r));\n      c.scrollTop = target;\n\n      const after = c.scrollTop;\n      console.debug(`[scroll] before=${before}, after=${after}, step=${this.scrollStep}`);\n\n      await this.delay(this.waitTime); // allow lazy load/network to happen\n    }\n\n    /* -------------------- Extraction -------------------- */\n    getVideoUrls() {\n      const urls = new Set();\n\n      // <video src>\n      document.querySelectorAll(\"video[src]\").forEach(v => {\n        const u = this.normalizeUrl(v.getAttribute(\"src\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // <source src> (nested or not)\n      document.querySelectorAll(\"source[src]\").forEach(s => {\n        const u = this.normalizeUrl(s.getAttribute(\"src\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // <a href=\"...mp4\">\n      document.querySelectorAll(\"a[href*='.mp4']\").forEach(a => {\n        const u = this.normalizeUrl(a.getAttribute(\"href\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // Conservative data-* URLs\n      document.querySelectorAll(\"[data-src],[data-url]\").forEach(el => {\n        const cand = el.getAttribute(\"data-src\") || el.getAttribute(\"data-url\");\n        const u = this.normalizeUrl(cand);\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // Extra custom selectors (if you know site-specific places to look)\n      for (const sel of this.extraSelectors) {\n        document.querySelectorAll(sel).forEach(el => {\n          const cand = this.normalizeUrl(el.getAttribute(\"src\") || el.getAttribute(\"href\"));\n          if (cand && cand.endsWith(\".mp4\")) urls.add(cand);\n        });\n      }\n\n      const arr = Array.from(urls);\n      console.debug(`[extract] found ${arr.length} candidates`);\n      return arr;\n    }\n\n    /* -------------------- Highlight & reveal -------------------- */\n    ensureHighlightStyles() {\n      if (document.getElementById('__video_pick_styles')) return;\n      const css = `\n        .video-picked {\n          border: 3px dotted #00ff3b !important; /* requested style */\n          border-radius: 12px;\n          box-shadow: 0 0 0 2px rgba(16,185,129,0.15);\n          transition: box-shadow 200ms ease;\n        }\n      `;\n      const style = document.createElement('style');\n      style.id = '__video_pick_styles';\n      style.textContent = css;\n      document.head.appendChild(style);\n    }\n\n    // IMPORTANT: the thumbnail/card container is the draggable card div.\n    getCardForNode(node) {\n      if (!(node instanceof HTMLElement)) return null;\n\n      // 1) Many grids wrap the video/source in a draggable card container\n      const card = node.closest('div[draggable=\"true\"]');\n      if (card) return card;\n\n      // 2) Fallback: try the nearest anchor wrapper if present\n      const anchor = node.closest('a');\n      if (anchor) return anchor;\n\n      // 3) Fallback: the node itself\n      return node;\n    }\n\n    scrollCardIntoView(card) {\n      const container = this.scrollContainer;\n      const cRect = container.getBoundingClientRect();\n      const eRect = card.getBoundingClientRect();\n\n      // center the card within the container viewport\n      const delta = (eRect.top - cRect.top) - (container.clientHeight - eRect.height) / 2;\n      container.scrollTop = Math.max(0, container.scrollTop + delta);\n    }\n\n    markAndReveal(url) {\n      try {\n        const esc = VideoURLCollector.cssEscape(url);\n\n        // Try matching both <video src> and <source src> nodes\n        const nodes = [\n          ...document.querySelectorAll(`video[src=\"${esc}\"]`),\n          ...document.querySelectorAll(`source[src=\"${esc}\"]`)\n        ];\n        if (!nodes.length) return;\n\n        const targetNode = nodes.find(n => n.offsetParent !== null) || nodes[0];\n        const card = this.getCardForNode(targetNode);\n        if (!card) return;\n\n        this.ensureHighlightStyles();\n        card.classList.add('video-picked');\n        this.scrollCardIntoView(card);\n      } catch (e) {\n        console.debug('markAndReveal skipped:', e);\n      }\n    }\n\n    /* -------------------- Save & dedupe -------------------- */\n    saveUrl(url) {\n      const before = this.videoUrls.size;\n      if (url) this.videoUrls.add(url);\n      const added = this.videoUrls.size > before;\n\n      if (added) {\n        console.log(`+ saved: ${url}  [${this.videoUrls.size}/${this.maxVideos}]`);\n        // Highlight and scroll this card into view\n        this.markAndReveal(url);\n      }\n      return added;\n    }\n\n    saveUrls(urls) {\n      let added = 0;\n      urls.forEach(u => { if (this.saveUrl(u)) added++; });\n      return added;\n    }\n\n    /* -------------------- New content detection -------------------- */\n    async waitForNewContent() {\n      const timeoutMs = this.loadTimeout;\n      return new Promise((resolve) => {\n        let timer = null;\n        const finish = (result) => {\n          clearTimeout(timer);\n          observer.disconnect();\n          resolve(result);\n        };\n\n        const observer = new MutationObserver((mutations) => {\n          for (const m of mutations) {\n            if (!m.addedNodes || !m.addedNodes.length) continue;\n            for (const n of m.addedNodes) {\n              if (!(n instanceof HTMLElement)) continue;\n              if (\n                n.matches?.(\"video, source, a[href*='.mp4'], [data-src*='.mp4'], [data-url*='.mp4']\") ||\n                n.querySelector?.(\"video, source, a[href*='.mp4'], [data-src*='.mp4'], [data-url*='.mp4']\")\n              ) {\n                console.debug('[observer] new video-ish node detected');\n                finish(true);\n                return;\n              }\n            }\n          }\n        });\n\n        // Observe inside the scroll container (not whole document)\n        const root = this.scrollContainer;\n        observer.observe(root, { childList: true, subtree: true });\n        timer = setTimeout(() => finish(false), timeoutMs);\n      });\n    }\n\n    /* -------------------- Main loop -------------------- */\n    async main() {\n      if (this.isRunning) {\n        console.warn('Collector is already running; returning current URLs.');\n        return this.getCollectedUrls();\n      }\n      this.isRunning = true;\n      console.log(`Starting collection (target=${this.maxVideos})`);\n\n      let staleRounds = 0;\n\n      try {\n        // Grab whatever is already on screen\n        const initial = this.getVideoUrls();\n        this.saveUrls(initial);\n        if (initial.length) this.markAndReveal(initial[0]);\n\n        while (this.videoUrls.size < this.maxVideos && staleRounds < this.maxStaleRounds) {\n          if (!this.canScrollDown()) {\n            console.log('Reached bottom (no more scroll).');\n            break;\n          }\n\n          await this.scrollAndWait();\n          const newContent = await this.waitForNewContent();\n\n          const newlyFound = this.saveUrls(this.getVideoUrls());\n          if (newlyFound === 0) {\n            staleRounds++;\n            console.log(`No new URLs this round (${staleRounds}/${this.maxStaleRounds})`);\n            await this.delay(300 + staleRounds * 150); // mild backoff\n          } else {\n            staleRounds = 0;\n          }\n        }\n\n        const result = this.getCollectedUrls().slice(0, this.maxVideos);\n        window.__collectedMp4Urls__ = result; // expose for convenience\n        console.log(`âœ… Done. Collected ${result.length} unique .mp4 URLs.`);\n        if (result.length < this.maxVideos) {\n          console.log(`Note: target was ${this.maxVideos}, feed may not have more videos or selectors need tweaking.`);\n        }\n        return result;\n\n      } catch (err) {\n        console.error('Collection error:', err);\n        return this.getCollectedUrls();\n      } finally {\n        this.isRunning = false;\n      }\n    }\n\n    /* -------------------- Public helpers -------------------- */\n    getCollectedUrls() { return Array.from(this.videoUrls); }\n\n    reset() {\n      this.videoUrls.clear();\n      this.isRunning = false;\n      console.log('Collector reset.');\n    }\n\n    exportUrls(filename = 'video-urls.txt') {\n      const urls = this.getCollectedUrls();\n      const blob = new Blob([urls.join('\\n')], { type: 'text/plain' });\n      const href = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = href;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(href);\n      console.log(`Exported ${urls.length} URLs to ${filename}`);\n    }\n  }\n\n  // Convenience utility API\n  const VideoCollectorUtils = {\n    async collectVideos(maxVideos = 25, options = {}) {\n      const collector = new VideoURLCollector({ maxVideos, ...options });\n      return await collector.main();\n    },\n    createCollector(options = {}) {\n      return new VideoURLCollector(options);\n    },\n    async downloadVideos(urls, delayMs = 1000) {\n      console.log(`Starting download of ${urls.length} videos...`);\n      for (let i = 0; i < urls.length; i++) {\n        try {\n          const a = document.createElement('a');\n          a.href = urls[i];\n          a.download = `video_${String(i + 1).padStart(2, '0')}.mp4`;\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          console.log(`Initiated download ${i + 1}/${urls.length}`);\n          if (i < urls.length - 1) await new Promise(r => setTimeout(r, delayMs));\n        } catch (e) {\n          console.error(`Failed download ${i + 1}:`, e);\n        }\n      }\n    }\n  };\n\n  // Expose to window for easy use in DevTools\n  window.VideoURLCollector = VideoURLCollector;\n  window.VideoCollectorUtils = VideoCollectorUtils;\n\n  console.log('VideoURLCollector loaded. Example:');\n  console.log(`const c = new VideoURLCollector({ scrollContainer: document.getElementById('pageScroll') });`);\n  console.log('await c.main(); c.exportUrls();');\n})();\n\nfunction transformUrlsToObjects(urls) {\n  return urls.map(videoUrl => {\n    const match = videoUrl.match(/\\/video\\/([^/]+)\\//);\n    const videoName = match ? match[1] : null;\n    const pageUrl = videoName \n      ? `https://www.midjourney.com/jobs/${videoName}?index=0`\n      : null;\n    const downloaded = false;\n    return { videoUrl, pageUrl, videoName, downloaded };\n  });\n}\n\n// FIXED VERSION: Proper async handling for Automa\nasync function runVideoCollection() {\n  try {\n    console.log('Starting video collection...');\n    const urls = await VideoCollectorUtils.collectVideos(100);\n    console.log(`Collected ${urls.length} video URLs`);\n    \n    const videos = transformUrlsToObjects(urls);\n    console.log(`Transformed to ${videos.length} video objects`);\n    \n    // Set the variable for Automa\n    automaSetVariable('videos', videos);\n    \n    // Small delay to ensure variable is set\n    setTimeout(() => {\n      console.log('Moving to next block...');\n      automaNextBlock();\n    }, 100);\n    \n  } catch (error) {\n    console.error('Error in video collection:', error);\n    // Set empty array as fallback\n    automaSetVariable('videos', []);\n    automaNextBlock();\n  }\n}\n\n// Run the collection\nrunVideoCollection();","context":"website","description":"","disableBlock":false,"everyNewTab":false,"preloadScripts":[],"runBeforeLoad":false,"timeout":20000},"id":"j3zta88","initialized":false,"label":"javascript-code","position":{"x":897.399009170294,"y":259.9648640823976},"type":"BlockBasic"},{"data":{"disableBlock":false},"id":"vj0n92n","initialized":false,"label":"active-tab","position":{"x":565.1767894698655,"y":95.04983027776674},"type":"BlockBasic"},{"data":{"assignVariable":true,"body":"{\n  \"videos\":{{!variables@videos}}\n}\n","contentType":"json","dataColumn":"","dataPath":"","description":"","disableBlock":false,"headers":[],"method":"POST","responseType":"json","saveData":false,"timeout":10000,"url":"http://localhost:5000/dailyvids","variableName":"response"},"id":"c3kvt56","initialized":false,"label":"webhook","position":{"x":1209.9932283327375,"y":398.7345029243309},"type":"BlockBasicWithFallback"},{"data":{"description":"","disableBlock":false,"iconUrl":"","imageUrl":"","message":"{{!variables@response}}","title":"RESPONSE"},"id":"0gr5xyo","initialized":false,"label":"notification","position":{"x":1543.9281793580392,"y":280.1135680842534},"type":"BlockBasic"},{"data":{"description":"","disableBlock":false,"iconUrl":"","imageUrl":"","message":"SERVER NOT FOUND","title":"ERROR SERVER"},"id":"jl836mq","initialized":false,"label":"notification","position":{"x":1542.2744313102482,"y":601.2085836718308},"type":"BlockBasic"},{"data":{"activeInInput":false,"contextMenuName":"","contextTypes":[],"date":"","days":[],"delay":5,"description":"","disableBlock":false,"interval":60,"isUrlRegex":false,"observeElement":{"baseElOptions":{"attributeFilter":[],"attributes":false,"characterData":false,"childList":true,"subtree":false},"baseSelector":"","matchPattern":"","selector":"","targetOptions":{"attributeFilter":[],"attributes":false,"characterData":false,"childList":true,"subtree":false}},"parameters":[],"preferParamsInTab":false,"shortcut":"","time":"00:00","triggers":[{"data":{"activeInInput":false,"contextMenuName":"","contextTypes":[],"date":"","days":[],"delay":5,"description":"","disableBlock":false,"interval":60,"isUrlRegex":false,"observeElement":{"baseElOptions":{"attributeFilter":[],"attributes":false,"characterData":false,"childList":true,"subtree":false},"baseSelector":"","matchPattern":"","selector":"","targetOptions":{"attributeFilter":[],"attributes":false,"characterData":false,"childList":true,"subtree":false}},"parameters":[],"preferParamsInTab":false,"shortcut":"","time":"00:00","type":"manual","url":""},"id":"ii-eI","type":"manual"},{"data":{"days":[{"id":0,"times":["00:00"]},{"id":2,"times":["00:00"]},{"id":4,"times":["00:00"]},{"id":6,"times":["00:00"]},{"id":1,"times":["00:00"]},{"id":5,"times":["00:00"]},{"id":3,"times":["00:00"]}],"time":"00:00"},"id":"uDybg","type":"specific-day"},{"data":{"contextMenuName":"midvideo-downloader ðŸŽ¥ðŸŽ¨","contextTypes":[]},"id":"WuJZt","type":"context-menu"}],"type":"manual","url":""},"id":"ra25aif","initialized":false,"label":"trigger","position":{"x":190.25049451088682,"y":258.6686981520108},"type":"BlockBasic"},{"data":{"activeTab":true,"createIfNoMatch":true,"description":"","disableBlock":false,"findTabBy":"match-patterns","matchPattern":"https://www.midjourney.com/explore?tab=video_top","tabIndex":0,"tabTitle":"","url":"https://www.midjourney.com/explore?tab=video_top"},"id":"tldasqk","initialized":false,"label":"switch-tab","position":{"x":564.9058589345846,"y":258.5813910980315},"type":"BlockBasic"}],"position":[-70.54260465368964,142.34310932676055],"viewport":{"x":-70.54260465368964,"y":142.34310932676055,"zoom":0.51590538845195},"zoom":0.51590538845195},"settings":{"aipowerToken":"","blockDelay":0,"debugMode":false,"defaultColumnName":"column","execContext":"popup","executedBlockOnWeb":false,"inputAutocomplete":true,"insertDefaultColumn":false,"notification":true,"onError":"stop-workflow","publicId":"","restartTimes":3,"reuseLastState":false,"saveLog":true},"globalData":"{\n\t\"key\": \"value\"\n}","description":"","includedWorkflows":{}}
{"extVersion":"1.29.12","name":"Midvideo-downloader ðŸŽ¥ðŸŽ¨","icon":"riGlobalLine","table":[],"version":"1.29.12","drawflow":{"nodes":[{"id":"j3zta88","type":"BlockBasic","initialized":false,"position":{"x":893.4305061822022,"y":236.15384615384608},"data":{"disableBlock":false,"description":"","timeout":100000,"context":"website","code":"(() => {\n  class VideoURLCollector {\n    constructor(options = {}) {\n      // --- Required scroll container: #pageScroll\n      const container = options.scrollContainer || document.getElementById('pageScroll');\n      if (!container) {\n        throw new Error('Scroll container #pageScroll not found. Ensure the page has <div id=\"pageScroll\">.');\n      }\n      this.scrollContainer = container;\n\n      // --- Config\n      this.maxVideos       = options.maxVideos ?? 25;\n      this.waitTime        = options.waitTime ?? 900;      // ms after each scroll\n      this.loadTimeout     = options.loadTimeout ?? 4000;  // max wait for new nodes per round\n      this.maxStaleRounds  = options.maxStaleRounds ?? 6;  // stop if N rounds produce 0 new URLs\n\n      // Sensible default step: ~80% of viewport height (min 200)\n      const defaultStep    = Math.max(200, Math.floor(this.scrollContainer.clientHeight * 0.8));\n      this.scrollStep      = options.scrollStep ?? defaultStep;\n\n      // Optional site-specific selectors to scan for URLs (src/href)\n      this.extraSelectors  = options.extraSelectors ?? [];\n\n      this.videoUrls = new Set();\n      this.isRunning = false;\n    }\n\n    /* -------------------- Utilities -------------------- */\n    delay(ms) { return new Promise(res => setTimeout(res, ms)); }\n\n    // CSS.escape fallback (older engines)\n    static cssEscape(str) {\n      if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(str);\n      return String(str).replace(/[^a-zA-Z0-9_\\-]/g, s => '\\\\' + s.charCodeAt(0).toString(16) + ' ');\n    }\n\n    normalizeUrl(url) {\n      if (!url) return null;\n      try {\n        const u = new URL(url, location.href);\n        u.hash = \"\"; // strip hash to reduce dupes\n        return u.href;\n      } catch {\n        return null;\n      }\n    }\n\n    getScrollMetrics() {\n      const c = this.scrollContainer;\n      return {\n        top: c.scrollTop,\n        height: c.clientHeight,\n        scrollHeight: c.scrollHeight\n      };\n    }\n\n    canScrollDown() {\n      const { top, height, scrollHeight } = this.getScrollMetrics();\n      return top + height < (scrollHeight - 1);\n    }\n    canScrollUp() {\n      const { top } = this.getScrollMetrics();\n      return top > 0;\n    }\n\n    /* -------------------- Scrolling -------------------- */\n    async scrollAndWait() {\n      const c = this.scrollContainer;\n      const { top, height, scrollHeight } = this.getScrollMetrics();\n\n      // Nudge up a bit (helps some lazy-loaders re-fire intersections)\n      if (this.canScrollUp()) {\n        c.scrollTop = Math.max(0, top - Math.floor(this.scrollStep / 3));\n        await this.delay(80);\n      }\n\n      // Scroll down by step without overshooting bottom\n      const before = c.scrollTop;\n      const target = Math.min(before + this.scrollStep, scrollHeight - height);\n      c.scrollTop = target;\n\n      // Write again on next frame to defeat throttling\n      await new Promise(r => requestAnimationFrame(r));\n      c.scrollTop = target;\n\n      const after = c.scrollTop;\n      console.debug(`[scroll] before=${before}, after=${after}, step=${this.scrollStep}`);\n\n      await this.delay(this.waitTime); // allow lazy load/network to happen\n    }\n\n    /* -------------------- Extraction -------------------- */\n    getVideoUrls() {\n      const urls = new Set();\n\n      // <video src>\n      document.querySelectorAll(\"video[src]\").forEach(v => {\n        const u = this.normalizeUrl(v.getAttribute(\"src\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // <source src> (nested or not)\n      document.querySelectorAll(\"source[src]\").forEach(s => {\n        const u = this.normalizeUrl(s.getAttribute(\"src\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // <a href=\"...mp4\">\n      document.querySelectorAll(\"a[href*='.mp4']\").forEach(a => {\n        const u = this.normalizeUrl(a.getAttribute(\"href\"));\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // Conservative data-* URLs\n      document.querySelectorAll(\"[data-src],[data-url]\").forEach(el => {\n        const cand = el.getAttribute(\"data-src\") || el.getAttribute(\"data-url\");\n        const u = this.normalizeUrl(cand);\n        if (u && u.endsWith(\".mp4\")) urls.add(u);\n      });\n\n      // Extra custom selectors (if you know site-specific places to look)\n      for (const sel of this.extraSelectors) {\n        document.querySelectorAll(sel).forEach(el => {\n          const cand = this.normalizeUrl(el.getAttribute(\"src\") || el.getAttribute(\"href\"));\n          if (cand && cand.endsWith(\".mp4\")) urls.add(cand);\n        });\n      }\n\n      const arr = Array.from(urls);\n      console.debug(`[extract] found ${arr.length} candidates`);\n      return arr;\n    }\n\n    /* -------------------- Highlight & reveal -------------------- */\n    ensureHighlightStyles() {\n      if (document.getElementById('__video_pick_styles')) return;\n      const css = `\n        .video-picked {\n          border: 3px dotted #00ff3b !important; /* requested style */\n          border-radius: 12px;\n          box-shadow: 0 0 0 2px rgba(16,185,129,0.15);\n          transition: box-shadow 200ms ease;\n        }\n      `;\n      const style = document.createElement('style');\n      style.id = '__video_pick_styles';\n      style.textContent = css;\n      document.head.appendChild(style);\n    }\n\n    // IMPORTANT: the thumbnail/card container is the draggable card div.\n    getCardForNode(node) {\n      if (!(node instanceof HTMLElement)) return null;\n\n      // 1) Many grids wrap the video/source in a draggable card container\n      const card = node.closest('div[draggable=\"true\"]');\n      if (card) return card;\n\n      // 2) Fallback: try the nearest anchor wrapper if present\n      const anchor = node.closest('a');\n      if (anchor) return anchor;\n\n      // 3) Fallback: the node itself\n      return node;\n    }\n\n    scrollCardIntoView(card) {\n      const container = this.scrollContainer;\n      const cRect = container.getBoundingClientRect();\n      const eRect = card.getBoundingClientRect();\n\n      // center the card within the container viewport\n      const delta = (eRect.top - cRect.top) - (container.clientHeight - eRect.height) / 2;\n      container.scrollTop = Math.max(0, container.scrollTop + delta);\n    }\n\n    markAndReveal(url) {\n      try {\n        const esc = VideoURLCollector.cssEscape(url);\n\n        // Try matching both <video src> and <source src> nodes\n        const nodes = [\n          ...document.querySelectorAll(`video[src=\"${esc}\"]`),\n          ...document.querySelectorAll(`source[src=\"${esc}\"]`)\n        ];\n        if (!nodes.length) return;\n\n        const targetNode = nodes.find(n => n.offsetParent !== null) || nodes[0];\n        const card = this.getCardForNode(targetNode);\n        if (!card) return;\n\n        this.ensureHighlightStyles();\n        card.classList.add('video-picked');\n        this.scrollCardIntoView(card);\n      } catch (e) {\n        console.debug('markAndReveal skipped:', e);\n      }\n    }\n\n    /* -------------------- Save & dedupe -------------------- */\n    saveUrl(url) {\n      const before = this.videoUrls.size;\n      if (url) this.videoUrls.add(url);\n      const added = this.videoUrls.size > before;\n\n      if (added) {\n        console.log(`+ saved: ${url}  [${this.videoUrls.size}/${this.maxVideos}]`);\n        // Highlight and scroll this card into view\n        this.markAndReveal(url);\n      }\n      return added;\n    }\n\n    saveUrls(urls) {\n      let added = 0;\n      urls.forEach(u => { if (this.saveUrl(u)) added++; });\n      return added;\n    }\n\n    /* -------------------- New content detection -------------------- */\n    async waitForNewContent() {\n      const timeoutMs = this.loadTimeout;\n      return new Promise((resolve) => {\n        let timer = null;\n        const finish = (result) => {\n          clearTimeout(timer);\n          observer.disconnect();\n          resolve(result);\n        };\n\n        const observer = new MutationObserver((mutations) => {\n          for (const m of mutations) {\n            if (!m.addedNodes || !m.addedNodes.length) continue;\n            for (const n of m.addedNodes) {\n              if (!(n instanceof HTMLElement)) continue;\n              if (\n                n.matches?.(\"video, source, a[href*='.mp4'], [data-src*='.mp4'], [data-url*='.mp4']\") ||\n                n.querySelector?.(\"video, source, a[href*='.mp4'], [data-src*='.mp4'], [data-url*='.mp4']\")\n              ) {\n                console.debug('[observer] new video-ish node detected');\n                finish(true);\n                return;\n              }\n            }\n          }\n        });\n\n        // Observe inside the scroll container (not whole document)\n        const root = this.scrollContainer;\n        observer.observe(root, { childList: true, subtree: true });\n        timer = setTimeout(() => finish(false), timeoutMs);\n      });\n    }\n\n    /* -------------------- Main loop -------------------- */\n    async main() {\n      if (this.isRunning) {\n        console.warn('Collector is already running; returning current URLs.');\n        return this.getCollectedUrls();\n      }\n      this.isRunning = true;\n      console.log(`Starting collection (target=${this.maxVideos})`);\n\n      let staleRounds = 0;\n\n      try {\n        // Grab whatever is already on screen\n        const initial = this.getVideoUrls();\n        this.saveUrls(initial);\n        if (initial.length) this.markAndReveal(initial[0]);\n\n        while (this.videoUrls.size < this.maxVideos && staleRounds < this.maxStaleRounds) {\n          if (!this.canScrollDown()) {\n            console.log('Reached bottom (no more scroll).');\n            break;\n          }\n\n          await this.scrollAndWait();\n          const newContent = await this.waitForNewContent();\n\n          const newlyFound = this.saveUrls(this.getVideoUrls());\n          if (newlyFound === 0) {\n            staleRounds++;\n            console.log(`No new URLs this round (${staleRounds}/${this.maxStaleRounds})`);\n            await this.delay(300 + staleRounds * 150); // mild backoff\n          } else {\n            staleRounds = 0;\n          }\n        }\n\n        const result = this.getCollectedUrls().slice(0, this.maxVideos);\n        window.__collectedMp4Urls__ = result; // expose for convenience\n        console.log(`âœ… Done. Collected ${result.length} unique .mp4 URLs.`);\n        if (result.length < this.maxVideos) {\n          console.log(`Note: target was ${this.maxVideos}, feed may not have more videos or selectors need tweaking.`);\n        }\n        return result;\n\n      } catch (err) {\n        console.error('Collection error:', err);\n        return this.getCollectedUrls();\n      } finally {\n        this.isRunning = false;\n      }\n    }\n\n    /* -------------------- Public helpers -------------------- */\n    getCollectedUrls() { return Array.from(this.videoUrls); }\n\n    reset() {\n      this.videoUrls.clear();\n      this.isRunning = false;\n      console.log('Collector reset.');\n    }\n\n    exportUrls(filename = 'video-urls.txt') {\n      const urls = this.getCollectedUrls();\n      const blob = new Blob([urls.join('\\n')], { type: 'text/plain' });\n      const href = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = href;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(href);\n      console.log(`Exported ${urls.length} URLs to ${filename}`);\n    }\n  }\n\n  // Convenience utility API\n  const VideoCollectorUtils = {\n    async collectVideos(maxVideos = 25, options = {}) {\n      const collector = new VideoURLCollector({ maxVideos, ...options });\n      return await collector.main();\n    },\n    createCollector(options = {}) {\n      return new VideoURLCollector(options);\n    },\n    async downloadVideos(urls, delayMs = 1000) {\n      console.log(`Starting download of ${urls.length} videos...`);\n      for (let i = 0; i < urls.length; i++) {\n        try {\n          const a = document.createElement('a');\n          a.href = urls[i];\n          a.download = `video_${String(i + 1).padStart(2, '0')}.mp4`;\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          console.log(`Initiated download ${i + 1}/${urls.length}`);\n          if (i < urls.length - 1) await new Promise(r => setTimeout(r, delayMs));\n        } catch (e) {\n          console.error(`Failed download ${i + 1}:`, e);\n        }\n      }\n    }\n  };\n\n  // Expose to window for easy use in DevTools\n  window.VideoURLCollector = VideoURLCollector;\n  window.VideoCollectorUtils = VideoCollectorUtils;\n\n  console.log('VideoURLCollector loaded. Example:');\n  console.log(`const c = new VideoURLCollector({ scrollContainer: document.getElementById('pageScroll') });`);\n  console.log('await c.main(); c.exportUrls();');\n  \n\n})();\n\nfunction transformUrlsToObjects(urls) {\n  return urls.map(videoUrl => {\n    const match = videoUrl.match(/\\/video\\/([^/]+)\\//);\n    const videoName = match ? match[1] : null;\n    const pageUrl = videoName \n      ? `https://www.midjourney.com/jobs/${videoName}?index=0`\n      : null;\n    const downloaded = false;\n    return { videoUrl, pageUrl, videoName, downloaded };\n  });\n}\n\n// Example\n(async () => {\n  const urls = await VideoCollectorUtils.collectVideos(500);\n  const videos = transformUrlsToObjects(urls);\n  automaSetVariable('videos',videos)\n  console.log(videos);\n  automaNextBlock()\n})();\n\n","preloadScripts":[],"everyNewTab":false,"runBeforeLoad":false},"label":"javascript-code"},{"id":"vj0n92n","type":"BlockBasic","initialized":false,"position":{"x":549.7921761680242,"y":48.895990372242125},"data":{"disableBlock":false},"label":"active-tab"},{"id":"c3kvt56","type":"BlockBasicWithFallback","initialized":false,"position":{"x":1229.9932283327375,"y":455.6575798474078},"data":{"disableBlock":false,"description":"","url":"http://localhost:5000/dailyvids","body":"{\n  \"videos\":{{!variables@videos}}\n}\n","headers":[],"method":"POST","timeout":10000,"dataPath":"","contentType":"json","variableName":"response","assignVariable":true,"saveData":false,"dataColumn":"","responseType":"json"},"label":"webhook"},{"id":"0gr5xyo","type":"BlockBasic","initialized":false,"position":{"x":1578.8182975907869,"y":237.47009024422889},"data":{"disableBlock":false,"description":"","message":"{{!variables@response}}","iconUrl":"","imageUrl":"","title":"RESPONSE"},"label":"notification"},{"id":"j3zlkn0","type":"BlockBasic","initialized":false,"position":{"x":229.17854541599866,"y":248.38257199161916},"data":{"disableBlock":false,"description":"","type":"manual","interval":60,"delay":5,"date":"","time":"00:00","url":"","shortcut":"","activeInInput":false,"isUrlRegex":false,"days":[],"contextMenuName":"","contextTypes":[],"parameters":[],"preferParamsInTab":false,"observeElement":{"selector":"","baseSelector":"","matchPattern":"","targetOptions":{"subtree":false,"childList":true,"attributes":false,"attributeFilter":[],"characterData":false},"baseElOptions":{"subtree":false,"childList":true,"attributes":false,"attributeFilter":[],"characterData":false}},"triggers":[{"type":"manual","data":{"disableBlock":false,"description":"","type":"manual","interval":60,"delay":5,"date":"","time":"00:00","url":"","shortcut":"","activeInInput":false,"isUrlRegex":false,"days":[],"contextMenuName":"","contextTypes":[],"parameters":[],"preferParamsInTab":false,"observeElement":{"selector":"","baseSelector":"","matchPattern":"","targetOptions":{"subtree":false,"childList":true,"attributes":false,"attributeFilter":[],"characterData":false},"baseElOptions":{"subtree":false,"childList":true,"attributes":false,"attributeFilter":[],"characterData":false}}},"id":"U_YLs"},{"id":"iCYex","type":"context-menu","data":{"contextMenuName":"Midvideo-downloader ðŸŽ¥ðŸŽ¨","contextTypes":[]}}]},"label":"trigger"}],"edges":[{"id":"vueflow__edge-vj0n92nvj0n92n-output-1-j3zta88j3zta88-input-1","type":"custom","source":"vj0n92n","target":"j3zta88","sourceHandle":"vj0n92n-output-1","targetHandle":"j3zta88-input-1","updatable":true,"selectable":true,"data":{},"label":"","markerEnd":"arrowclosed","sourceX":765.7920209099586,"sourceY":84.89595373038469,"targetX":869.4304950017136,"targetY":272.1538840406299},{"id":"vueflow__edge-j3zta88j3zta88-output-1-c3kvt56c3kvt56-input-1","type":"custom","source":"j3zta88","target":"c3kvt56","sourceHandle":"j3zta88-output-1","targetHandle":"c3kvt56-input-1","updatable":true,"selectable":true,"data":{},"label":"","markerEnd":"arrowclosed","sourceX":1109.4303509241367,"sourceY":272.1538840406299,"targetX":1205.993217152249,"targetY":503.6575487957947},{"id":"vueflow__edge-c3kvt56c3kvt56-output-1-0gr5xyo0gr5xyo-input-1","type":"custom","source":"c3kvt56","target":"0gr5xyo","sourceHandle":"c3kvt56-output-1","targetHandle":"0gr5xyo-input-1","updatable":true,"selectable":true,"data":{},"label":"","markerEnd":"arrowclosed","sourceX":1445.9932221319546,"sourceY":503.6575487957947,"targetX":1554.8184354675807,"targetY":273.47012813101276},{"id":"vueflow__edge-j3zlkn0j3zlkn0-output-1-vj0n92nvj0n92n-input-1","type":"custom","source":"j3zlkn0","target":"vj0n92n","sourceHandle":"j3zlkn0-output-1","targetHandle":"vj0n92n-input-1","updatable":true,"selectable":true,"data":{},"label":"","markerEnd":"arrowclosed","sourceX":445.17846468657444,"sourceY":284.3825726140824,"targetX":525.7921649875356,"targetY":84.89595373038469}],"position":[434.99338980481707,413.4101720815348],"zoom":0.3,"viewport":{"x":434.99338980481707,"y":413.4101720815348,"zoom":0.3}},"settings":{"publicId":"","aipowerToken":"","blockDelay":0,"saveLog":true,"debugMode":false,"restartTimes":3,"notification":true,"execContext":"popup","reuseLastState":false,"inputAutocomplete":true,"onError":"stop-workflow","executedBlockOnWeb":false,"insertDefaultColumn":false,"defaultColumnName":"column"},"globalData":"{\n\t\"key\": \"value\"\n}","description":"","includedWorkflows":{}}